"""Module with utility functions (and CLI) to rename .pdb files so that they're compatible with the AMBER forcefield.

!! Note !! The functions:
rename_residues, rename_charged, labeledPDB_to_AmberPDB, renumber_atoms,
nest_pdb, unnest_pdb, get_coords, disulfide_search, pdb_cleanup, histidine_search,
atom_is_present, rename_termini

are all Python3 adaptations from the original repository / module:
https://github.com/choderalab/mmtools/blob/master/mccetools/rename.py

to use this module, you can use the following code:
`pdb_to_amber -i <pdb_file>`
"""

import argparse
from ..logger import logger
import os
import sys
import math


def rename_residues(pdbarr, renameTermini=True, terminology='AMBER'):
    logger.debug(f"At start of renaming, pdbarr has {len(pdbarr)} items")
    npdb = nest_pdb(pdbarr)
    logger.debug(f"Nest/unnest leads to {len(unnest_pdb(npdb))}, items")
    npdb = rename_charged(npdb, terminology=terminology)
    npdb = histidine_search(npdb)
    npdb = disulfide_search(npdb, terminology=terminology)
    print('### renameTermini =', renameTermini)
    if renameTermini:
        npdb = rename_termini(npdb)
    pdbarr = unnest_pdb(npdb)
    return pdbarr

def rename_charged(npdb, terminology = 'AMBER'):
    """Generate AMBER-specific residue names for charged residues from MCCE residue names. Also fix some problems with atom naming (specifically hydrogens) for charged residues.
        
    ARGUMENTS
        npdb - "nested" PDB data structure generated by nest_pdb. Modified to reflect AMBER names.

    OPTIONAL ARGUMENTS
        terminology       default 'AMBER', which protonates residues using naming recognized by AMBER and the ffamber ports for GROMACS from the Sorin lab. 
                          Optionally, specify 'gAMBER' for the GROMACS AMBER format, which has some slightly different residue naming conventions 
                          (for example, LYP -> LYS, LYS -> LYN, and CYN -> CYS, CYS2 -> CYM )

    CHANGE LOG:
    - DLM 7-1-2009: Modified to fix naming of HE1 in GLH to HE2 to conform to ffamber rtp.
    - DFV 20-02-2024: adapted to python3 & added logger.
    """
    for i, res in enumerate(npdb):
        original_resname = res[0][17:20]
        resname_and_state = res[-1][17:20] + res[-1][-1]
        if resname_and_state == 'HIS+':
            npdb[i] = [x.replace('HIS', 'HIP') for x in npdb[i]]
        elif (resname_and_state[i]=='LYS0'):
            if terminology == 'AMBER':
                npdb[i]=[x.replace('LYS','LYN') for x in npdb[i]]
            elif terminology == 'gAMBER':
                npdb[i]=[x.replace('LYS','LYN') for x in npdb[i]]
        elif (resname_and_state[i]=='LYS+'):
            if terminology =='AMBER':
                npdb[i]=[x.replace('LYS','LYP') for x in npdb[i]]
            if terminology =='gAMBER':
                npdb[i]=[x.replace('LYS','LYS') for x in npdb[i]]
        elif (resname_and_state[i]=='CYS0'):
            if terminology =='AMBER':
                npdb[i]=[x.replace('CYS','CYN') for x in npdb[i]]
            elif terminology =='gAMBER':
                npdb[i]=[x.replace('CYS','CYS') for x in npdb[i]]
        elif (resname_and_state[i]=='CYS-'):
            npdb[i]=[x.replace('CYS','CYM') for x in npdb[i]]
        elif (resname_and_state[i]=='ASP0'):
            npdb[i]=[x.replace('ASP','ASH') for x in npdb[i]]
            #DLM 8/25/2009: ASH needs to have HD2, not HD1, for some reason
            npdb[i]=[x.replace('HD1 ASH','HD2 ASH') for x in npdb[i]]
        #Aspartate requires no sub
        elif (resname_and_state[i]=='GLU0'):
            npdb[i]=[x.replace('GLU','GLH') for x in npdb[i]]
            #DLM 7-1-2009: Fix GLY HE1 to HE2
            npdb[i] = [x.replace('HE1 GLH','HE2 GLH') for x in npdb[i]]
        
        new_resname = res[0][17:20] # keep track for the log message
        if original_resname != new_resname:
            logger.info(f"Residue {i+1}: {original_resname} renamed to {new_resname}.")
    return npdb

def labeledPDB_to_AmberPDB(labeledPDBfile, outPDBfile, renameResidues=True):
    with open(labeledPDBfile, 'r') as fin:
        lines = fin.readlines()
    pdbarr = []
    while lines:
        pdbline = lines.pop(0)
        label = lines.pop(0).strip()
        pdbarr.append(pdbline.strip() + label)
    if renameResidues:
        pdbarr = rename_residues(pdbarr)
    pdbarr = pdb_cleanup(pdbarr)
    with open(outPDBfile, 'w') as fout:
        for line in pdbarr:
            fout.write(f"{line}\n")
            
def renumber_atoms(pdbarr):
    for i, line in enumerate(pdbarr):
        pdbarr[i] = f"{line[:6]}{str(i+1).rjust(5)}{line[11:]}"

def nest_pdb(pdbarr):
    nestedpdb = []
    residue = []
    usedatoms = []
    for line in pdbarr:
        atom = line[12:17].strip()
        if not residue or line[17:27] != residue[-1][17:27] or atom in usedatoms:
            if residue: nestedpdb.append(residue)
            residue = [line]
            usedatoms = [atom]
        else:
            residue.append(line)
            usedatoms.append(atom)
    if residue:
        nestedpdb.append(residue)
    return nestedpdb

def unnest_pdb(npdb):
    return [atm for res in npdb for atm in res]

def get_coords(atomname, residue):
    for line in residue:
        if line[12:16].strip() == atomname.strip():
            return tuple(float(line[i:i+8]) for i in range(30, 54, 8))
    raise ValueError("Atom not found!")

def disulfide_search(npdb, min_dist=1.8, max_dist=2.2, terminology='AMBER'):
    residues_to_rename = set()
    for i in range(len(npdb)):
        if npdb[i][0][17:20] not in ['CYS', 'CYD']:
            continue
        iX, iY, iZ = get_coords('SG', npdb[i])
        for j in range(i + 1, len(npdb)):
            if npdb[j][0][17:20] not in ['CYS', 'CYD']:
                continue
            jX, jY, jZ = get_coords('SG', npdb[j])
            distance = math.sqrt((iX - jX) ** 2 + (iY - jY) ** 2 + (iZ - jZ) ** 2)
            if min_dist <= distance <= max_dist:
                residues_to_rename.update({i, j})
    
    for i in residues_to_rename:
        if terminology == 'AMBER':
            npdb[i] = [x.replace('CYS ', 'CYS2') if 'CYS' in x else x.replace('CYD ', 'CYS2') for x in npdb[i]]
        elif terminology == 'gAMBER':
            npdb[i] = [x.replace('CYS ', 'CYX') if 'CYS' in x else x.replace('CYD ', 'CYX') for x in npdb[i]]
    
    return npdb

def pdb_cleanup(pdbarr):
    updated_pdbarr = []
    for line in pdbarr:
        atom = line[:54]  # Truncate each line to the first 54 characters (up to the end of the coordinates)
        atomsymbol = line[12:16].strip(" 0123456789")[0]  # Extract the atom symbol
        updated_line = f"{atom}  1.00  0.00          {atomsymbol.rjust(2)}"  # Format the line with default occupancy and B-factor, and reposition the atom symbol
        updated_pdbarr.append(updated_line)

    npdb = nest_pdb(updated_pdbarr)  # Nest the PDB for further processing if needed
    
    # Renumber residues and set chain identifiers if required
    for i, residue in enumerate(npdb):
        for j, line in enumerate(residue):
            # Assume chain identifier is blank for simplicity; adjust if handling multi-chain PDBs
            npdb[i][j] = f"{line[:21]} {' ':1}{str(i + 1).rjust(4)}{'    '}{line[30:]}"

    return unnest_pdb(npdb)  # Return the unnested, cleaned-up PDB array

def histidine_search(npdb):
    for i in range(len(npdb)):
        resname = npdb[i][0][17:20]
        if resname == 'HIS':
            HE_present = atom_is_present(npdb[i], 'HE2')  # bonded to NE2
            HD_present = atom_is_present(npdb[i], 'HD1')  # bonded to ND1

            if HD_present and HE_present:
                npdb[i] = [x.replace('HIS', 'HIP') for x in npdb[i]]
            elif HE_present:
                npdb[i] = [x.replace('HIS', 'HIE') for x in npdb[i]]
            elif HD_present:
                npdb[i] = [x.replace('HIS', 'HID') for x in npdb[i]]
            else:
                raise ValueError("No protons found for histidine.")
    return npdb

def atom_is_present(pdblines, atomname):
    """Returns TRUE if the given atom is present in the given PDB atom lines.
    
    ARGUMENTS
        pdblines - list of PDB lines
        atomname - the name of the atom to check the existence of

    RETURNS
        is_present - True if the given atom name is present, False otherwise

    """
    atoms = [pdbline[13:16] for pdbline in pdblines]
    if any(atomname in atom for atom in atoms):
        return True
    else:
        return False
    
def rename_termini(npdb):
    NTerminiRes = []
    CTerminiRes = []
    for i in range(len(npdb)):
        if npdb[i][0][17:20] in ['NTR', 'NTG']:
            NTerminiRes.append(i)
        if npdb[i][0][17:20] == 'CTR':
            CTerminiRes.append(i)

    if len(NTerminiRes) != len(CTerminiRes):
        raise ValueError("Mismatch in the number of N-terminal and C-terminal residues.")

    for k in range(len(CTerminiRes)):
        NResIndex = NTerminiRes[k]
        CResIndex = CTerminiRes[k]

        ntrname = npdb[NResIndex+1][0][17:20]
        ctrname = npdb[CResIndex-1][0][17:20]

        # Rename N-terminal residues
        for j in [NResIndex, NResIndex+1]:
            npdb[j] = [x.replace('NTR', 'N' + ntrname).replace('NTG', 'N' + ntrname) for x in npdb[j]]

        # Rename C-terminal residues and terminal oxygen atoms
        for j in [CResIndex-1, CResIndex]:
            npdb[j] = [x.replace('CTR', 'C' + ctrname) for x in npdb[j]]
            npdb[j] = [x.replace(' O ', ' OC1') if ' O ' in x else x.replace('OXT', 'OC2') for x in npdb[j]]

    return npdb

def main_exe():
    parser = argparse.ArgumentParser(description="Rename amino acids in a PDB file for AMBER forcefield compatibility.")
    parser.add_argument('-i', '--input', required=True, help="Input PDB file to process")
    parser.add_argument('-o', '--output', required=False, help="Output name for the processed file", default=None)
    args = parser.parse_args()

    input_pdb_path = args.input
    if not os.path.exists(input_pdb_path):
        logger.error(f"Input file {input_pdb_path} does not exist.")
        sys.exit(1)

    logger.info(f"Processing file: {input_pdb_path}")

    try:
        with open(input_pdb_path, 'r') as f:
            pdb_lines = f.readlines()
        
        renamed_pdb_lines = rename_residues(pdb_lines)
        if args.output is not None:
            output_pdb_path = args.output
        else:
            output_pdb_path = input_pdb_path.replace('.pdb', '_renamed.pdb')

        with open(output_pdb_path, 'w') as f:
            for line in renamed_pdb_lines:
                f.write(line)

        logger.info(f"Renaming completed. Output file: {output_pdb_path}")

    except Exception as e:
        logger.error(f"An error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main_exe()
